---
title: "Notes For Part Two"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Notes For Part Two}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

![Rdlazer][confusedcat]

# Data Structures And Their Properties

\newline

## I Vector

- a **vector** is a sequence of items in a certain order
- it is a 1-dimensional structure of any **length** (number of items)
- a vector is the simplest data structure in R, hence it is called **atomic**
- an example of a vector is `letters`
- virtually every data object is some kind of vector
- even a single data point, e.g. a `TRUE`, is actually a vector of length 1
- a vector can store only one type of data, e.g. logical or character, thus it has a type
- vectors are created with the function `vector`: it can create any type (mode) of vector of any length
- constructors for particular types exist: `logical`, `numeric`, `character`
- functions exist for testing and converting types: `is.character`, `as.character`, etc.

\newline

- vectors are most commonly built by concatenating/merging vectors with the function `c`
```{r}
# merge two character vectors of length one
c('one', 'two')
```
- types will often be changed to suit a called function: this is called **coercion**
```{r}
# merge a character vector with a numeric one
c('one', 1)
# the numeric was (silently!) coerced to character
```

```{r}
# concatenate existing vectors (variables) with one created ad hoc
v1 <- c('one', 'two')
v2 <- c(1, 2)
v3 <- c(v1, v2, c(FALSE, TRUE))
v3
```
- a vector can be treated as a set
- use `%in%` to test if something is an element of a vector:
```{r}
'one' %in% v3
```
- a vector can contain duplicated elements
- use `anyDuplicated` to test if that is the case
- use `unique` to get unique elements of a vector

\newline

- inspect the beginning or end of a vector with `head` or `tail`, respectively
- sort a vector with `sort`
- reverse the item order with `rev`
- replicate a vecotr with `rep`

\newline

- a vector can have additional features, such as properties or information
- these are called **attributes**
- all attributes of an object can be viewed with the function `attributes`
- a specific attribute can be viewed with `attr`
- a frequently encountered attribute is **names**: unique character strings associated with each item
- a vector that has a names attribute is a **named vecotr**
- see `.romans` for a named vector of Roman numerals
- names can be viewed with `names(x)` and set with `names(x) <- [vector of names]`, much like assigning a variable
- this would be equivalent to `attr(x, 'names')`; `names` exists for convenience, as messing with names is such a common action
```{r}
# get names
names(v2)

#set names
names(v2) <- c('first', 'second')
names(v2)

# remove names
names(v2) <- NULL
names(v2)
```
- a vector can also be created with names when using `c`
- elements are given as `name = value` pairs
```{r}
v4 <- c('first' = 1, 'second' = 2, 'third' = 3)
names(v4)

# the names need not be quoted
v4 <- c(first = 1, second = 2, third = 3)
```

- we will discuss more attributes when appropriate but names will keep coming back
- the function `as.vector` will strip all atributes, leaving a bare vector

#### Every vector has a type and a length. It can also have attributes.



\newline

## II Vectorized Operations

- most operations in R are vectorized
- they are applied to each vector element separately and return a vector of the same length
```{r}
n <- 1:10

# mathematical operation
n + 1

# change case
toupper(letters)
```
- operations involving two vectors are done item by item, by matching indices (1st with 1st, etc.)
```{r}
n1 <- 1:4
n2 <- 4:1

n1
n2
n1 + n2
n1 / n2
```
- when the lengths of the vectors do not match, the shorter vector is **recycled**
- this can lead to unexpected results, so watch out
```{r}
n3 <- rep(4, 4)
n4 <- 1:2

n3 + n4

l1 <- c(TRUE, FALSE)
paste(n3, l1)
```

\newline

- of course, some operations do not deal with every element of a vector separately
```{r}
s1 <- names(v4)
s1

length(s1)
```
- but many do
```{r}
nchar(s1)
```



\newline

## III Subsetting

- **subsetting** is when we pick out a subset of a vector
- any language allows for subsetting an element from a sequence
- R is especially robust and flexible with it
- subsetting is done with the `[` operator

\newline

- this simplest case is getting the *n*-th element of a vector
```{r}
v3[1]
```
- the index (the number in the brackets) is not a number - it is a vector of length 1
- it may be longer
```{r}
ind <- c(1,3)
v3[ind]
```
- **the indices need not be unique**
```{r}
ind <- c(1, 1, 3, 4, 6, 6)
v3[ind]
```
- if a vector is named, names can be used as indices
```{r}
v4['first']
ind <- c('first', 'second', 'first', 'first')
v4[ind]
```
- subsetting can also be done with a logical vector, typically of the same length
```{r}
ind <- c(T, T, F, T, F, F)
v3[ind]
```
- a logical vector does not refer to indices and therefore its length matters
```{r}
ten <- 1:10
x <- letters[ten]
x

# too long an index produces NAs
ind <- rep(T, 11)
x[ind]

# too short an index is recycled
ind <- c(T, T, F)
x[ind]

ind <- TRUE
x[ind]
```



\newline

## IV Matrix

- a matrix is a 2-dimensional data structure
- it has rows (dimension 1) and columns (dimension 2)
- a matrix is created with the function `matrix`
```{r}
m <- matrix(1:12, nrow = 3, ncol = 4)
m
```
- by default a matrix is filled **by columns**, i.e. 1st column from 1st to last row, then 2nd column, etc.; this can be modified wyth the `byrow` argument of `matrix`
- a matrx can be transposed with the funcion `t`
```{r}
t(m)
```
- we can check the number of rows and columns with `nrow` and `ncol`, respectively

\newline

- a matrix is not a special atomic type with unique properties
- it is merely a vector with an attribute **dim**
- dim can be viewed or set with a special function `dim`
```{r}
# get dimensions
dim(m)
# the first number is the number of rows and the second is the number of columns

# the attribute can be modified as will, even removed
dim(m) <- NULL
m
# note that the matrix is dismantled in the same way is is built by default:
# column after column

# dim can be set on any vector as long as the grid size matches its length
dim(m) <- c(4,3)
m
# note that, again, the matrix is build in the default order
```
- since a matrix is basically a vector, it can hold only one type of data
- it also has a length:
```{r}
length(m)
```

#### subsetting a matrix
- when subsetting a matrix, we must account for it having two dimensions
- specify the range of each dimension and separate them with a comma:
```{r}
m[1,3]
m[1:2, 2:3]
```
- leaving one index empty will yield a whole row/column
- be aware this returns a vector, not a 1 row matrix!
```{r}
m1 <- m[1, ]
is.matrix(m1)
is.vector(m1)
```
- in order to preserve tha matrix nature of the result, we must set the `drop` argument to FALSE:
```{r}
m2 <- m[1, , drop = FALSE]
# mind the empty second dimension!
```
- since it is a vector, we can also subset using a single index, bypassing the dimensions:
```{r}
m[1]
m[7]
```

\newline

- a matrix can be extended by adding rows or columns with `rbind` and `cbind`, respectively:
```{r}
rbind(m, 101:103)
cbind(m, letters[1:4])
# note the coercion
```
- `c` would do no good here as it strips attributes other than names
```{r}
c(m, m)
cbind(m,m)
```

\newline

- a matrix's dimensions can be named:
```{r}
rownames(m) <- letters[1:4]
colnames(m) <- LETTERS[1:3]
m
```
- we can now use the names for subsetting
```{r}
m['a', 'B']
m['a', c('A', 'B'), drop = FALSE]
m[c('a', 'b'), c('A', 'B')]
```
- the row and column names are stored a single attribute **dimnames**
- dimanmes can be viewed or set with the function `dimnames`
- it is structured as a list (more on lists below)



\newline

## V List

- a list is a special type of vector
- in a list any item can be of **any type** - including a list
- this is called a **recursive** object
- look at `state.center` and `ability.cov` for examples of lists

\newline

- a list is constructed with the function `list`
- much like `c`, `list` takes a number of objects and returns a list object
- concatenate lists with `c` ro `append`
- using `list` to add items to a list will take your list and put it in a higher order list
- turn a vector into a list with `as.list` and do the reverse with `unlist`
- a list can be named just like any other vector


<h4>subsetting a list <br>
<font size = 1> it's a bit of a mess... </font>
</h4>

- like any vector, a list can be subsetted
- however, the special structure of a list calls for special measures

\newline

- using the normal, **single bracket** returns a subset of the list
- all normal rules apply
- the result is always a list
```{r}
# subset with numeric index
ability.cov[2]
ind <- 2:3
ability.cov[ind]

# subset with names
ind <- 'n.obs'
ability.cov[ind]

# subset with logical vector
ind <- c(T, F, F)
ability.cov[ind]

# it's a list
x <- ability.cov[1]
x
is.list(x)
```

- using a **double bracket** will return the contents of that level of the list
- a single bracket accepts only **single indices**
- logically, how else would you return two items of a list other than as a list?
```{r}
# numeric
ability.cov[[3]]

# names
ability.cov[['n.obs']]

# it's not a list
x <- ability.cov[[1]]
x
is.list(x)
is.matrix(x)
```

- there is a special **dollar** operator for subsetting lists: `$`
- it only accepts bare names of list elements: `ablity.cov$center`
- it does exactly the same thing as a double bracket
```{r}
state.center$x
```

<h4> A list is a kind of vector that can hold any item. <br>
Subsetting a list with `[` yields a list of any length. Using `[[` or `$` yields a single list item.
<h4>


```{r eval=FALSE, include=FALSE}

\newline

## VI R's syntactic flexibility








# ## VII Data Frame
# - the data frame is pehaps the most often used data structure

```

[confusedcat]: ../images/confused.jpg
